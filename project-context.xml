<?xml version="1.0" encoding="UTF-8"?>
<projectContext>
  <projectInfo>
  <name>demo-recorder</name>
  <version>1.0.0</version>
  <dependencies>
    <dependency>
      <name>mouse-helper</name>
      <version>^1.0.7</version>
    </dependency>
    <dependency>
      <name>puppeteer</name>
      <version>^24.0.0</version>
    </dependency>
    <dependency>
      <name>toml</name>
      <version>^3.0.0</version>
    </dependency>
  </dependencies>
</projectInfo>
  <fileTree>
    <![CDATA[
├── .demo-recorder.toml
├── README.md
├── example-config.toml
├── package-lock.json
├── package.json
├── project-context.xml
├── recordings/
│   ├── content-flow.mp4
│   └── login-flow-with-pauses.mp4
├── src/
│   ├── actions/
│   │   ├── InputActions.ts
│   │   ├── MouseActions copy.ts
│   │   ├── MouseActions.ts
│   │   └── SelectActions.ts
│   ├── config.ts
│   ├── index.ts
│   ├── recorder/
│   │   ├── CustomScreenRecorder.ts
│   │   └── types.ts
│   └── utils/
│       ├── browser.ts
│       ├── delay.ts
│       └── mouse-helper.ts
├── tsconfig.json
└── yarn.lock

    ]]>
  </fileTree>
  <fileContents>
    
          <file>
            <path>package.json</path>
            <content><![CDATA[{
  "name": "demo-recorder",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "init": "ts-node src/index.ts init",
    "record": "ts-node src/index.ts record",
    "start": "ts-node src/index.ts",
    "prepare": "npm run build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "mouse-helper": "^1.0.7",
    "puppeteer": "^24.0.0",
    "toml": "^3.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.10.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.3"
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/actions/InputActions.ts</path>
            <content><![CDATA[// src/actions/InputActions.ts
import { Page } from 'puppeteer';
import { MouseActions } from './MouseActions';
import { delay } from '../utils/delay';

export interface TypeOptions {
  delay?: number;
  isTextarea?: boolean;
}

export class InputActions {
  private mouseActions: MouseActions;

  constructor(private page: Page) {
    this.mouseActions = new MouseActions(page);
  }

  async typeText(selector: string, text: string, options: TypeOptions = {}) {
    const { 
      delay: typeDelay = 100, 
      isTextarea = false 
    } = options;

    // Use mouse movement for more natural interaction
    const targetSelector = isTextarea ? `${selector} textarea` : selector;
    await this.mouseActions.click(targetSelector);
    
    // Ensure element is focused
    await this.page.focus(targetSelector);
    
    // Type with delay for natural appearance
    await this.page.type(targetSelector, text, { delay: typeDelay });
    
    // Small pause after typing
    await delay(500);
  }

  async clearAndType(selector: string, text: string, options: TypeOptions = {}) {
    const targetSelector = options.isTextarea ? `${selector} textarea` : selector;
    
    await this.mouseActions.click(targetSelector);
    await this.page.focus(targetSelector);
    
    // Clear existing content
    await this.page.keyboard.down('Control');
    await this.page.keyboard.press('A');
    await this.page.keyboard.up('Control');
    await this.page.keyboard.press('Backspace');
    
    // Type new content
    await this.typeText(selector, text, options);
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/actions/MouseActions.ts</path>
            <content><![CDATA[// src/actions/MouseActions.ts
import { Page } from 'puppeteer';
import { delay } from '../utils/delay';
import { MouseHelper } from '../utils/mouse-helper';

declare global {
  interface Window {
    'mouse-helper': () => void;
  }
}

export interface MouseMoveOptions {
  minSteps?: number;
  maxSteps?: number;
  minDelay?: number;
  maxDelay?: number;
  shouldClick?: boolean;
}

export class MouseActions {
  private currentX: number = 0;
  private currentY: number = 0;
  private isMoving: boolean = false;
  private isInitialized: boolean = false;
  private isRestoringPosition: boolean = false;
  private readonly defaultPosition: { x: number, y: number };
  private lastKnownGoodPosition: { x: number, y: number } | null = null;
  private positionRestoreTimeout: NodeJS.Timeout | null = null;
  private lastRestoreTime: number = 0;
  private readonly RESTORE_DEBOUNCE = 100; // ms

  constructor(private page: Page) {
    const viewport = page.viewport();
    this.defaultPosition = {
      x: viewport ? viewport.width / 2 : 640,
      y: viewport ? viewport.height / 2 : 400
    };
    this.currentX = this.defaultPosition.x;
    this.currentY = this.defaultPosition.y;
    this.lastKnownGoodPosition = { ...this.defaultPosition };

    // Handle navigation with proper debouncing
    page.on('framenavigated', async (frame) => {
      if (frame === page.mainFrame()) {
        // Clear any pending restoration
        if (this.positionRestoreTimeout) {
          clearTimeout(this.positionRestoreTimeout);
        }

        // Wait for page to stabilize before restoring position
        this.positionRestoreTimeout = setTimeout(async () => {
          if (Date.now() - this.lastRestoreTime >= this.RESTORE_DEBOUNCE) {
            await this.debouncedRestorePosition();
          }
        }, this.RESTORE_DEBOUNCE);
      }
    });
  }

  private async debouncedRestorePosition(): Promise<void> {
    if (Date.now() - this.lastRestoreTime < this.RESTORE_DEBOUNCE || this.isMoving) {
      return;
    }

    try {
      const position = this.lastKnownGoodPosition || this.defaultPosition;
      await this.page.mouse.move(position.x, position.y);
      this.currentX = position.x;
      this.currentY = position.y;
      this.lastRestoreTime = Date.now();
      console.log(`Position restored to: { x: ${position.x}, y: ${position.y} }`);
    } catch (error) {
      console.error('Error restoring position:', error);
    }
  }

  private async waitForMovementComplete(): Promise<void> {
    const startTime = Date.now();
    while (this.isMoving && Date.now() - startTime < 1000) {
      await delay(50);
    }
    // Force release if stuck
    if (this.isMoving) {
      console.warn('Movement lock timeout - forcing release');
      this.isMoving = false;
    }
  }

  async ensureInitialized() {
    if (!this.isInitialized) {
      try {
        await this.restorePosition();
        this.isInitialized = true;
        console.log(`Mouse position initialized to: ${this.currentX}, ${this.currentY}`);
      } catch (error) {
        console.warn('Failed to initialize mouse position:', error);
        // Don't throw, use default position
        await this.setMousePosition(this.defaultPosition.x, this.defaultPosition.y);
      }
    }
  }

  private async setMousePosition(x: number, y: number, skipLastKnownUpdate = false) {
    // Don't update position if we're in the middle of a restore operation
    if (Date.now() - this.lastRestoreTime < this.RESTORE_DEBOUNCE) {
      return;
    }

    try {
      await this.page.mouse.move(x, y);
      this.currentX = x;
      this.currentY = y;

      // Only update last known good position for intentional movements
      if (!skipLastKnownUpdate) {
        this.lastKnownGoodPosition = { x, y };
      }
    } catch (error) {
      console.error('Error setting mouse position:', error);
    }
  }

  async moveWithDelay(selector: string, options: MouseMoveOptions = {}) {
    if (this.isMoving) {
      await this.waitForMovementComplete();
    }
    
    this.isMoving = true;
    let succeeded = false;
    let targetX = 0;
    let targetY = 0;

    try {
      const element = await this.page.$(selector);
      if (!element) {
        console.warn(`Element not found: ${selector}`);
        return false;
      }

      const box = await element.boundingBox();
      if (!box) {
        console.warn(`Could not get bounding box for: ${selector}`);
        return false;
      }

      const startX = this.currentX;
      const startY = this.currentY;
      targetX = box.x + box.width / 2;
      targetY = box.y + box.height / 2;

      // Store current position before movement
      this.lastKnownGoodPosition = { x: startX, y: startY };

      // Use fixed number of steps for consistent speed
      const steps = 30;
      
      // Move in a straight line with fixed steps
      for (let i = 0; i <= steps; i++) {
        const progress = i / steps;
        const x = startX + (targetX - startX) * progress;
        const y = startY + (targetY - startY) * progress;

        await this.setMousePosition(x, y);
        await delay(10); // Fixed 10ms delay between steps
      }

      if (options.shouldClick) {
        await this.page.mouse.down();
        await delay(50 + Math.random() * 50);
        await this.page.mouse.up();
      }

      succeeded = true;
      return true;
    } catch (error) {
      console.error('Error during mouse movement:', error);
      return false;
    } finally {
      this.isMoving = false;
      if (succeeded) {
        this.lastKnownGoodPosition = { x: targetX, y: targetY };
      }
    }
  }

  async click(selector: string) {
    return this.moveWithDelay(selector, { shouldClick: true });
  }

  getPosition() {
    return { x: this.currentX, y: this.currentY };
  }



  async restorePosition() {
    if (this.isRestoringPosition || this.isMoving) {
      return;
    }

    this.isRestoringPosition = true;
    try {
      const position = this.lastKnownGoodPosition || this.defaultPosition;
      await this.page.mouse.move(position.x, position.y);
      this.currentX = position.x;
      this.currentY = position.y;
    } finally {
      this.isRestoringPosition = false;
    }
  }


  async smoothScroll(pixels: number, duration: number = 1000) {
    if (this.isMoving) {
      await this.waitForMovementComplete();
    }

    this.isMoving = true;

    try {
      // Don't reinitialize here
      const startY = this.currentY;
      const steps = Math.floor(duration / 16);
      const pixelsPerStep = pixels / steps;
      const stepDuration = duration / steps;

      for (let i = 0; i < steps; i++) {
        await this.page.evaluate((y) => {
          window.scrollBy(0, y);
        }, pixelsPerStep);

        await delay(stepDuration);
      }

      // Update position after scroll
      this.lastKnownGoodPosition = {
        x: this.currentX,
        y: this.currentY + pixels
      };
    } finally {
      this.isMoving = false;
    }
  }
}

export async function initializeMouseHelper(page: Page): Promise<void> {
  const mouseHelper = MouseHelper.getInstance();
  await mouseHelper.ensureInitialized(page);
}
]]></content>
          </file>
        
          <file>
            <path>src/config.ts</path>
            <content><![CDATA[// src/config.ts
import * as fs from 'fs';
import * as path from 'path';
import * as TOML from 'toml';
import { DemoConfig } from './recorder/types';

export function getConfigPath(targetDir: string): string {
  return path.join(targetDir, '.demo-recorder.toml');
}

export function getExampleConfigPath(): string {
  return path.join(__dirname, '..', 'example-config.toml');
}

export function createConfigFile(configPath: string): void {
  const exampleConfigPath = getExampleConfigPath();
  
  if (!fs.existsSync(exampleConfigPath)) {
    throw new Error('Example config file not found. Please ensure example-config.toml exists in the project root.');
  }

  fs.copyFileSync(exampleConfigPath, configPath);
  console.log(`Created new config file at ${configPath}`);
  console.log('Please customize the config file for your specific needs.');
}

function interpolateEnvVariables(obj: any): any {
  if (typeof obj === 'string') {
    return obj.replace(/\${([^}]+)}/g, (match, envVar) => {
      // Check if it's a nested reference like auth.email
      const parts = envVar.split('.');
      if (parts.length > 1) {
        return match; // Keep the original ${auth.email} format for nested refs
      }
      return process.env[envVar] || match;
    });
  }

  if (Array.isArray(obj)) {
    return obj.map(item => interpolateEnvVariables(item));
  }

  if (obj && typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = interpolateEnvVariables(value);
    }
    return result;
  }

  return obj;
}

function interpolateConfigReferences(config: any): any {
  let stringified = JSON.stringify(config);
  
  // Replace ${auth.email} and similar with actual values
  stringified = stringified.replace(/\${([^}]+)}/g, (match, path) => {
    const parts = path.split('.');
    let value = config;
    for (const part of parts) {
      if (value && typeof value === 'object' && part in value) {
        value = value[part];
      } else {
        return match; // Keep original if path not found
      }
    }
    return typeof value === 'string' ? value : match;
  });

  return JSON.parse(stringified);
}

export function readConfig(configPath: string): DemoConfig {
  try {
    const content = fs.readFileSync(configPath, 'utf-8');
    let config = TOML.parse(content) as DemoConfig;
    
    // First interpolate environment variables
    config = interpolateEnvVariables(config);
    
    // Then interpolate config references
    config = interpolateConfigReferences(config);
    
    return config;
  } catch (error) {
    console.error(`Error reading config at ${configPath}:`, error);
    throw error;
  }
}

export function ensureConfigExists(targetDir: string): string {
  const configPath = getConfigPath(targetDir);
  if (!fs.existsSync(configPath)) {
    createConfigFile(configPath);
  }
  return configPath;
}

export function initializeConfig(targetDir: string): DemoConfig {
  const configPath = ensureConfigExists(targetDir);
  return readConfig(configPath);
}
]]></content>
          </file>
        
          <file>
            <path>src/index.ts</path>
            <content><![CDATA[// src/index.ts
import * as path from 'path';
import * as fs from 'fs';
import { initializeConfig, ensureConfigExists } from './config';
import { DemoRecorder } from './recorder/CustomScreenRecorder';

// Get command line arguments
const args = process.argv.slice(2);
let command = 'record';  // default command
let targetDir = process.cwd();  // default directory

// If we have arguments, check their order
if (args.length > 0) {
  // If the first arg is a command, use it and look for dir in second arg
  if (args[0] === 'init' || args[0] === 'record') {
    command = args[0];
    targetDir = args[1] ? path.resolve(args[1]) : process.cwd();
  } else {
    // If first arg isn't a command, it must be the directory
    targetDir = path.resolve(args[0]);
  }
}

console.log(`Command: ${command}`);
console.log(`Target directory: ${targetDir}`);

async function init() {
  try {
    if (!fs.existsSync(targetDir)) {
      console.error(`Error: Target directory does not exist: ${targetDir}`);
      process.exit(1);
    }

    console.log(`Initializing demo recorder config in: ${targetDir}`);
    
    // This will create the config file if it doesn't exist
    const configPath = ensureConfigExists(targetDir);
    
    console.log('\nConfiguration file created successfully!');
    console.log(`Please edit ${configPath} to configure your recording steps.`);
    console.log('\nOnce configured, you can run:');
    console.log('demo-record');
    console.log('\nto start the recording.');

  } catch (error) {
    console.error('Initialization failed:', error);
    process.exit(1);
  }
}

async function record() {
  try {
    if (!fs.existsSync(targetDir)) {
      console.error(`Error: Target directory does not exist: ${targetDir}`);
      process.exit(1);
    }

    console.log(`Starting demo recorder for directory: ${targetDir}`);

    // Load and validate config
    const config = initializeConfig(targetDir);

    // Create output directory if specified in config
    const outputDir = path.dirname(path.join(targetDir, config.recording.output));
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Initialize and run recorder
    const recorder = new DemoRecorder(config);
    await recorder.record();

  } catch (error) {
    console.error('Recording failed:', error);
    process.exit(1);
  }
}

// Main execution
async function main() {
  try {
    switch (command) {
      case 'init':
        await init();
        break;
      case 'record':
        await record();
        break;
      default:
        console.error('Unknown command. Use "init" or "record"');
        process.exit(1);
    }
  } catch (error) {
    console.error('Unexpected error:', error);
    process.exit(1);
  }
}

// Run the main function
main().catch((error) => {
  console.error('Unexpected error:', error);
  process.exit(1);
});
]]></content>
          </file>
        
          <file>
            <path>src/recorder/CustomScreenRecorder.ts</path>
            <content><![CDATA[//src/recorder/CustomScreenRecorder.ts
import * as puppeteer from 'puppeteer';
import { spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import { MouseActions } from '../actions/MouseActions';
import { InputActions } from '../actions/InputActions';
import { SelectActions } from '../actions/SelectActions';
import { delay } from '../utils/delay';
import { DemoConfig, RecordingOptions } from './types';
import { initializeMouseHelper } from '../actions/MouseActions';

class CustomScreenRecorder {
  private ffmpeg: any;
  private frameCount: number = 0;
  private client: puppeteer.CDPSession | null = null;
  private isRecording: boolean = false;
  private isPaused: boolean = false;
  private pausedTime: number = 0;

  public getStatus() {
    return {
      isRecording: this.isRecording,
      isPaused: this.isPaused
    };
  }


  constructor(
    private page: puppeteer.Page,
    private options: RecordingOptions = {
      fps: 30,
      quality: 90,
      videoCrf: 18,
      videoCodec: 'libx264',
      videoPreset: 'ultrafast'
    }
  ) { }

  async start(outputPath: string): Promise<void> {
    // Ensure the output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    this.client = await this.page.createCDPSession();
    this.isRecording = true;
    this.isPaused = false;

    this.ffmpeg = spawn('ffmpeg', [
      '-y',
      '-f', 'image2pipe',
      '-r', `${this.options.fps}`,
      '-i', '-',
      '-c:v', this.options.videoCodec,
      '-preset', this.options.videoPreset,
      '-crf', `${this.options.videoCrf}`,
      '-pix_fmt', 'yuv420p',
      outputPath
    ]);

    this.ffmpeg.stderr.on('data', (data: Buffer) => {
      console.log(`FFmpeg: ${data.toString()}`);
    });

    await this.client.send('Page.startScreencast', {
      format: 'jpeg',
      quality: this.options.quality,
      everyNthFrame: 1
    });

    await this.client.on('Page.screencastFrame', async (frame) => {
      try {
        if (!this.client) return;

        this.ffmpeg.stdin.write(Buffer.from(frame.data, 'base64'));
        this.frameCount++;

        await this.client.send('Page.screencastFrameAck', {
          sessionId: frame.sessionId
        }).catch(console.error);
      } catch (error) {
        console.error('Error processing frame:', error);
      }
    });
  }

  async stop(): Promise<void> {
    if (this.client) {
      try {
        await this.client.send('Page.stopScreencast');
        this.ffmpeg.stdin.end();

        await new Promise<void>((resolve, reject) => {
          this.ffmpeg.on('close', (code: number) => {
            if (code === 0) {
              console.log(`Recording completed with ${this.frameCount} frames`);
              resolve();
            } else {
              reject(new Error(`FFmpeg exited with code ${code}`));
            }
          });
        });

        await this.client.detach();
        this.client = null;
      } catch (error) {
        console.error('Error stopping recording:', error);
        throw error;
      }
    }
  }

  async pause(): Promise<void> {
    if (!this.isRecording || this.isPaused) return;

    if (this.client) {
      await this.client.send('Page.stopScreencast');
      this.isPaused = true;
      this.pausedTime = Date.now();
      console.log('Recording paused');
    }
  }

  async resume(): Promise<void> {
    if (!this.isRecording || !this.isPaused) return;

    if (this.client) {
      await this.client.send('Page.startScreencast', {
        format: 'jpeg',
        quality: this.options.quality,
        everyNthFrame: 1
      });
      this.isPaused = false;
      console.log(`Recording resumed after ${Date.now() - this.pausedTime}ms pause`);
    }
  }
}

class DemoRecorder {
  private browser?: puppeteer.Browser;
  private page?: puppeteer.Page;
  private recorder?: CustomScreenRecorder;
  private mouseActions?: MouseActions;
  private inputActions?: InputActions;
  private selectActions?: SelectActions;

  constructor(private config: DemoConfig) { }

  async initialize() {
    this.browser = await puppeteer.launch({
      headless: false,
      defaultViewport: this.config.project.viewport
    });

    this.page = await this.browser.newPage();
    await initializeMouseHelper(this.page); 

    this.mouseActions = new MouseActions(this.page);
    this.recorder = new CustomScreenRecorder(this.page);
    this.inputActions = new InputActions(this.page);
    this.selectActions = new SelectActions(this.page);
  }

  async executeStep(step: any) {
    if (!this.page || !this.mouseActions || !this.inputActions || !this.selectActions) {
      throw new Error('Recorder not properly initialized');
    }

    try {
      console.log(`Executing step: ${step.type}`);

      switch (step.type) {
        case 'navigate':
          const currentPosition = this.mouseActions.getPosition();
          console.log(`Navigating to: ${this.config.project.baseUrl}${step.path}`);

          // Log position before navigation
          console.log('Position before navigation:', currentPosition);

          await this.page.goto(`${this.config.project.baseUrl}${step.path}`, {
            waitUntil: ['networkidle0', 'load']
          });
          // Restore mouse position after navigation
          await delay(1000); // Give time for page to stabilize
          await this.mouseActions.restorePosition();
          // Log position after restore
          const newPosition = this.mouseActions.getPosition();
          console.log('Position after navigation restore:', newPosition);
          break;

        case 'input':
          console.log(`Typing into: ${step.selector}`);
          const typeConfig = {
            ...this.config.recording.defaultTypeConfig,
            ...step.typeConfig
          };
          await this.inputActions.typeText(step.selector!, step.value!, {
            isTextarea: step.selector?.includes('textarea'),
            delay: typeConfig.slowType ? (typeConfig.typeDelay || 150) : 0
          });
          break;

        case 'select':
          console.log(`Selecting from: ${step.selector}`);
          await this.selectActions.select(step.selector!, step.option!);
          break;

        case 'click':
          console.log(`Clicking: ${step.selector}`);
          await this.mouseActions.click(step.selector!);
          break;

        case 'wait':
          console.log(`Waiting: ${step.duration}ms`);
          await delay(step.duration || 1000);
          break;

        case 'scrollDown':
          console.log(`Scrolling: ${step.pixels}px`);
          await this.mouseActions?.smoothScroll(
            step.pixels,
            step.duration || 1000
          );
          break;

        case 'startRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.start(this.config.recording.output);
          break;

        case 'stopRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.stop();
          break;

        case 'pauseRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.pause();
          break;

        case 'resumeRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.resume();
          break;

        default:
          console.warn(`Unknown step type: ${step.type}`);
      }
    } catch (error) {
      console.error(`Error executing step ${step.type}:`, error);
      throw error;
    }
  }

  async record() {
    try {
      await this.initialize();
      if (!this.page || !this.recorder) throw new Error('Failed to initialize');

      // Don't auto-start recording - wait for a startRecording step
      for (const step of this.config.steps) {
        await this.executeStep(step);
      }

      // Only stop if we're still recording at the end
      if (this.recorder.getStatus().isRecording) {
        console.log('Stopping recording...');
        await this.recorder.stop();
      }
    } catch (error) {
      console.error('Recording error:', error);
      throw error;
    } finally {
      if (this.browser) {
        await this.browser.close();
      }
    }
  }
}

export { CustomScreenRecorder, DemoRecorder };
]]></content>
          </file>
        
          <file>
            <path>src/recorder/types.ts</path>
            <content><![CDATA[// src/recorder/types.ts

export interface ViewportDimensions {
  width: number;
  height: number;
}

export interface RecordingOptions {
  fps: number;
  quality: number;
  videoCrf: number;
  videoCodec: string;
  videoPreset: string;
}

export interface TypeConfig {
  slowType?: boolean;
  typeDelay?: number;  // milliseconds between keystrokes
}

export interface Step {
  type: StepType;
  selector?: string;
  value?: string;
  option?: string;
  duration?: number;
  path?: string;
  typeConfig?: TypeConfig;
}

export type StepType = 
  | 'navigate' 
  | 'input' 
  | 'select' 
  | 'click' 
  | 'wait'
  | 'scrollDown'
  | 'startRecording'
  | 'stopRecording'
  | 'pauseRecording'
  | 'resumeRecording';

  export interface ScrollStep extends Step {
    type: 'scrollDown';
    pixels: number;
    duration?: number;  // milliseconds
    moveMouse?: boolean;
  }
export interface ProjectConfig {
  name: string;
  baseUrl: string;
  viewport: ViewportDimensions;
}

export interface AuthConfig {
  email?: string;
  password?: string;
}

export interface RecordingConfig {
  output: string;
  fps: number;
  quality: number;
  defaultTypeConfig?: TypeConfig;
}

export interface DemoConfig {
  project: ProjectConfig;
  auth?: AuthConfig;
  recording: RecordingConfig;
  steps: Step[];
}
]]></content>
          </file>
        
          <file>
            <path>src/utils/mouse-helper.ts</path>
            <content><![CDATA[// src/utils/mouse-helper.ts
import { Page } from 'puppeteer';
import * as fs from 'fs';
import { delay } from './delay';

export class MouseHelper {
  private static instance: MouseHelper;
  private initialized: boolean = false;
  private initPromise: Promise<void> | null = null;
  private mouseHelperContent: string | null = null;

  private constructor() {}

  static getInstance(): MouseHelper {
    if (!MouseHelper.instance) {
      MouseHelper.instance = new MouseHelper();
    }
    return MouseHelper.instance;
  }

  private async loadMouseHelperContent() {
    if (this.mouseHelperContent) return;

    try {
      const mouseHelperPath = require.resolve('mouse-helper/dist/mouse-helper.js');
      this.mouseHelperContent = fs.readFileSync(mouseHelperPath, 'utf8');
      console.log('Mouse helper content loaded, length:', this.mouseHelperContent.length);
    } catch (error) {
      console.error('Failed to load mouse helper content:', error);
      throw error;
    }
  }

  private async initializePage(page: Page): Promise<void> {
    if (!this.mouseHelperContent) {
      await this.loadMouseHelperContent();
    }

    await page.evaluateOnNewDocument(`
      window.self = window;
      ${this.mouseHelperContent}
      
      function initMouseHelper() {
        if (typeof window['mouse-helper'] === 'function') {
          try {
            window['mouse-helper']();
            console.log('Mouse helper initialized successfully');
          } catch (error) {
            console.error('Mouse helper initialization failed:', error);
          }
        }
      }

      // Initialize on page load
      if (document.readyState === 'complete') {
        initMouseHelper();
      } else {
        window.addEventListener('load', initMouseHelper);
      }

      // Backup initialization after a short delay
      setTimeout(initMouseHelper, 500);
    `);
  }

  async ensureInitialized(page: Page): Promise<boolean> {
    if (this.initPromise) {
      await this.initPromise;
      return this.initialized;
    }

    this.initPromise = this.initialize(page);
    try {
      await this.initPromise;
      return this.initialized;
    } finally {
      this.initPromise = null;
    }
  }

  private async initialize(page: Page): Promise<void> {
    if (this.initialized) return;

    try {
      await this.loadMouseHelperContent();
      await this.initializePage(page);

      // Try to initialize up to 3 times
      for (let attempt = 0; attempt < 3; attempt++) {
        try {
          const isHelperPresent = await page.evaluate(() => {
            return typeof window['mouse-helper'] === 'function';
          });

          if (isHelperPresent) {
            await page.evaluate(() => {
              window['mouse-helper']();
            });
            
            const helperElement = await page.$('.mouse-helper');
            if (helperElement) {
              console.log('Mouse helper initialized successfully on attempt', attempt + 1);
              this.initialized = true;
              return;
            }
          }

          if (attempt < 2) {
            await delay(100);
          }
        } catch (error) {
          console.warn(`Mouse helper init attempt ${attempt + 1} failed:`, error);
          if (attempt === 2) throw error;
        }
      }
    } catch (error) {
      console.error('Mouse helper initialization failed:', error);
      throw error;
    }
  }

  async reinitialize(page: Page): Promise<void> {
    this.initialized = false;
    this.initPromise = null;
    await this.ensureInitialized(page);
  }
}
]]></content>
          </file>
        
  </fileContents>
</projectContext>