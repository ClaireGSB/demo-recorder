<?xml version="1.0" encoding="UTF-8"?>
<projectContext>
  <projectInfo>
  <name>demo-recorder</name>
  <version>1.0.0</version>
  <dependencies>
    <dependency>
      <name>mouse-helper</name>
      <version>^1.0.7</version>
    </dependency>
    <dependency>
      <name>puppeteer</name>
      <version>^24.0.0</version>
    </dependency>
    <dependency>
      <name>toml</name>
      <version>^3.0.0</version>
    </dependency>
  </dependencies>
</projectInfo>
  <fileTree>
    <![CDATA[
├── .DS_Store
├── .demo-recorder.toml
├── README.md
├── example-config.toml
├── package-lock.json
├── package.json
├── project-context.xml
├── recordings/
│   ├── content-flow.mp4
│   └── login-flow-with-pauses.mp4
├── src/
│   ├── actions/
│   │   ├── InputActions.ts
│   │   ├── MouseActions.ts
│   │   └── SelectActions.ts
│   ├── config.ts
│   ├── index.ts
│   ├── recorder/
│   │   ├── CustomScreenRecorder.ts
│   │   └── types.ts
│   └── utils/
│       ├── browser.ts
│       ├── delay.ts
│       └── mouse-helper.ts
├── tsconfig.json
└── yarn.lock

    ]]>
  </fileTree>
  <fileContents>
    
          <file>
            <path>README.md</path>
            <content><![CDATA[# Demo Recorder

A tool for automatically recording web application demos using Puppeteer. Creates smooth, professional-looking demo videos with visible mouse movements and natural interactions.

## Features

- Record automated demos of web applications
- Smooth mouse movements with visual cursor indicator
- Support for various interactions:
  - Clicking elements
  - Typing in input fields and textareas
  - Selecting from dropdowns
  - Navigation
  - Timed waits
- Configurable recording settings
- TOML-based configuration

## Installation

1. Clone the repository:
```bash
git clone [your-repo-url]
cd demo-recorder
```

2. Install dependencies:
```bash
npm install
```

3. Add the tool to your shell configuration (`~/.bashrc` or `~/.zshrc`):
```bash
alias demo-record='function _demo_record() { npm run --prefix /absolute/path/to/demo-recorder start "$(pwd)"; }; _demo_record'
```

Replace `/absolute/path/to/demo-recorder` with the actual path where you cloned the repository.

4. Source your shell configuration:
```bash
source ~/.bashrc  # or source ~/.zshrc
```

## Usage

1. Create a `.demo-recorder.toml` file in your project directory:
```bash
cp /path/to/demo-recorder/.demo-recorder.template.toml /your/project/.demo-recorder.toml
```

2. Configure your recording steps in the TOML file

3. Run the recorder from your project directory:
```bash
demo-record
```

## Configuration Example

Here's a complete example of a `.demo-recorder.toml` file:

```toml
# Project configuration
[project]
name = "my-nuxt-app"
baseUrl = "http://localhost:3000"

[project.viewport]
width = 1280
height = 800

# Authentication (optional)
[auth]
email = "${DEMO_USER_EMAIL}"
password = "${DEMO_USER_PASSWORD}"

# Recording settings
[recording]
output = "recordings/login-flow.mp4"
fps = 30
quality = 90

# Demo recording steps
[[steps]]
type = "navigate"
path = "/login"

[[steps]]
type = "wait"
duration = 1000

[[steps]]
type = "input"
selector = "[type='email']"
value = "${auth.email}"

[[steps]]
type = "input"
selector = "[type='password']"
value = "${auth.password}"

[[steps]]
type = "click"
selector = "[type='submit']"

[[steps]]
type = "wait"
duration = 2000

[[steps]]
type = "select"
selector = "[data-test='content-type-select']"
option = "[data-test='content-type-twitter_post']"

[[steps]]
type = "input"
selector = "[data-test='topic']"
value = "The Future of AI"

[[steps]]
type = "input"
selector = "[data-test='additional_instructions'] textarea"
value = "Include specific examples and use cases"
```

## Step Types

### Navigate
```toml
[[steps]]
type = "navigate"
path = "/some-path"  # Will be appended to baseUrl
```

### Input
```toml
[[steps]]
type = "input"
selector = "[data-test='field-name']"
value = "Text to type"
```

### Select
```toml
[[steps]]
type = "select"
selector = "[data-test='dropdown']"
option = "[data-test='option-value']"  # Selector for the option to click
```

### Click
```toml
[[steps]]
type = "click"
selector = "[data-test='button']"
```

### Wait
```toml
[[steps]]
type = "wait"
duration = 2000  # milliseconds
```

## Environment Variables

Sensitive data like credentials should be provided through environment variables. Create a `.env` file in your project:

```bash
DEMO_USER_EMAIL=demo@example.com
DEMO_USER_PASSWORD=your-password
```

## Requirements

- Node.js 16+
- FFmpeg (for video recording)
- A running web application to record

## Troubleshooting

1. **Mouse Helper Not Visible**
   - Check if mouse-helper is installed: `npm install mouse-helper`

2. **Recording Fails**
   - Ensure FFmpeg is installed on your system
   - Check if the output directory exists
   - Verify all selectors in your config exist in the page

3. **Selectors Not Found**
   - Use browser dev tools to verify selectors
   - Ensure the page is fully loaded (add wait steps if needed)
   - Check if elements are in iframes or shadow DOM

## License

MIT]]></content>
          </file>
        
          <file>
            <path>example-config.toml</path>
            <content><![CDATA[# Project configuration
[project]
name = "demo-nuxt-app"
baseUrl = "http://localhost:3001"

[project.viewport]
width = 1280
height = 800

# Authentication settings (using environment variables)
[auth]
email = "${SCREENSHOT_LOGIN_EMAIL}"
password = "${SCREENSHOT_LOGIN_PASSWORD}"

# Recording settings
[recording]
output = "recordings/login-flow-with-pauses.mp4"
fps = 30
quality = 90

# Default typing configuration for all input steps
[recording.defaultTypeConfig]
slowType = false
typeDelay = 50  # Default to fast typing

# Demo recording steps
[[steps]]
type = "navigate"
path = "/login"

[[steps]]
type = "wait"
duration = 1000

[[steps]]
type = "startRecording"  # Explicitly start recording before login sequence

[[steps]]
type = "input"
selector = "[type='email']"
value = "${auth.email}"
typeConfig = { slowType = true, typeDelay = 150 }  # Override for slow typing

[[steps]]
type = "input"
selector = "[type='password']"
value = "${auth.password}"
# Uses default fast typing since no typeConfig specified

[[steps]]
type = "click"
selector = "[type='submit']"

[[steps]]
type = "wait"
duration = 1000

[[steps]]
type = "pauseRecording"  # Pause during the long loading time


# Navigate to content page
[[steps]]
type = "navigate"
path = "/content"

[[steps]]
type = "wait"
duration = 5000

[[steps]]
type = "resumeRecording" # Resume recording after the long loading time

# Select content type
[[steps]]
type = "select"
selector = "[data-test='content-type-select']"
option = "[data-test='content-type-twitter_post']"

[[steps]]
type = "wait"
duration = 500

# Select voice
[[steps]]
type = "select"
selector = "[data-test='voice-select']"
option = "[data-test='voice-Nativish']"

[[steps]]
type = "wait"
duration = 500

# Select action
[[steps]]
type = "click"
selector = "[data-test='action-select']"

[[steps]]
type = "wait"
duration = 1000

[[steps]]
type = "click"
selector = "[data-test='write_topic']"

[[steps]]
type = "wait"
duration = 1000

# Fill topic field
[[steps]]
type = "input"
selector = "[data-test='topic']"
value = "The Future of AI Development"
typeConfig = { slowType = true, typeDelay = 200 }

[[steps]]
type = "wait"
duration = 1000

# Fill additional instructions
[[steps]]
type = "input"
selector = "[data-test='additional_instructions']"
value = "Include specific examples of AI tools in development workflows."
# Uses default fast typing since no typeConfig specified

[[steps]]
type = "wait"
duration = 6000

[[steps]]
type = "stopRecording" ]]></content>
          </file>
        
          <file>
            <path>package.json</path>
            <content><![CDATA[{
  "name": "demo-recorder",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "init": "ts-node src/index.ts init",
    "record": "ts-node src/index.ts record",
    "start": "ts-node src/index.ts",
    "prepare": "npm run build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "mouse-helper": "^1.0.7",
    "puppeteer": "^24.0.0",
    "toml": "^3.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.10.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.3"
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/actions/InputActions.ts</path>
            <content><![CDATA[// src/actions/InputActions.ts
import { Page } from 'puppeteer';
import { MouseActions } from './MouseActions';
import { delay } from '../utils/delay';

export interface TypeOptions {
  delay?: number;
  isTextarea?: boolean;
}

export class InputActions {
  private mouseActions: MouseActions;

  constructor(private page: Page) {
    this.mouseActions = new MouseActions(page);
  }

  async typeText(selector: string, text: string, options: TypeOptions = {}) {
    const { 
      delay: typeDelay = 100, 
      isTextarea = false 
    } = options;

    // Use mouse movement for more natural interaction
    const targetSelector = isTextarea ? `${selector} textarea` : selector;
    await this.mouseActions.click(targetSelector);
    
    // Ensure element is focused
    await this.page.focus(targetSelector);
    
    // Type with delay for natural appearance
    await this.page.type(targetSelector, text, { delay: typeDelay });
    
    // Small pause after typing
    await delay(500);
  }

  async clearAndType(selector: string, text: string, options: TypeOptions = {}) {
    const targetSelector = options.isTextarea ? `${selector} textarea` : selector;
    
    await this.mouseActions.click(targetSelector);
    await this.page.focus(targetSelector);
    
    // Clear existing content
    await this.page.keyboard.down('Control');
    await this.page.keyboard.press('A');
    await this.page.keyboard.up('Control');
    await this.page.keyboard.press('Backspace');
    
    // Type new content
    await this.typeText(selector, text, options);
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/actions/MouseActions.ts</path>
            <content><![CDATA[// src/actions/MouseActions.ts
import { Page } from 'puppeteer';
import { delay } from '../utils/delay';

export interface MouseMoveOptions {
  delayMs?: number;
  shouldClick?: boolean;
  steps?: number;
}

export class MouseActions {
  private currentX: number = 0;
  private currentY: number = 0;

  constructor(private page: Page) {}

  async moveWithDelay(selector: string, options: MouseMoveOptions = {}) {
    const { 
      delayMs = 500, 
      shouldClick = true,
      steps = 25 
    } = options;

    const element = await this.page.$(selector);
    if (!element) {
      console.warn(`Element not found: ${selector}`);
      return false;
    }

    const box = await element.boundingBox();
    if (!box) {
      console.warn(`Could not get bounding box for: ${selector}`);
      return false;
    }

    const startX = this.currentX;
    const startY = this.currentY;
    const endX = box.x + box.width / 2;
    const endY = box.y + box.height / 2;

    // Smooth mouse movement
    for (let i = 0; i <= steps; i++) {
      const x = startX + (endX - startX) * (i / steps);
      const y = startY + (endY - startY) * (i / steps);
      await this.page.mouse.move(x, y);
      this.currentX = x;
      this.currentY = y;
      await delay(delayMs / steps);
    }

    if (shouldClick) {
      await this.page.mouse.down();
      await delay(100);
      await this.page.mouse.up();
      await delay(200);
    }

    return true;
  }

  async click(selector: string) {
    return this.moveWithDelay(selector, { shouldClick: true });
  }

  getPosition() {
    return { x: this.currentX, y: this.currentY };
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/actions/SelectActions.ts</path>
            <content><![CDATA[// src/actions/SelectActions.ts
import { Page, ElementHandle } from 'puppeteer';
import { MouseActions } from './MouseActions';
import { delay } from '../utils/delay';

export class SelectActions {
  private mouseActions: MouseActions;

  constructor(private page: Page) {
    this.mouseActions = new MouseActions(page);
  }

  async select(selectSelector: string, optionSelector: string) {
    // Open the select
    await this.mouseActions.click(selectSelector);
    
    // Wait for options to be visible
    await delay(500);
    
    // Select the option
    await this.mouseActions.click(optionSelector);
    
    // Wait for select to close
    await delay(500);
  }

  async selectByText(selectSelector: string, text: string) {
    await this.mouseActions.click(selectSelector);
    await delay(500);

    try {
      // Use page.$ instead of evaluateHandle for proper typing
      const options = await this.page.$$(`${selectSelector} .v-list-item`);
      
      for (const option of options) {
        const textContent = await option.evaluate(el => el.textContent);
        if (textContent?.includes(text)) {
          await option.click();
          await delay(500);
          return;
        }
      }
      
      console.warn(`Option with text "${text}" not found in select ${selectSelector}`);
    } catch (error) {
      console.error(`Error selecting option: ${error}`);
    }
  }

  async selectByTextSimple(selectSelector: string, text: string) {
    try {
      await this.mouseActions.click(selectSelector);
      await delay(500);

      // Use waitForSelector to ensure the list is visible
      const optionSelector = `${selectSelector} .v-list-item`;
      await this.page.waitForSelector(optionSelector, { visible: true });

      // First find all options
      const options = await this.page.$$(optionSelector);
      
      // Then find the one with matching text
      for (const option of options) {
        const textContent = await this.page.evaluate(el => el.textContent, option);
        if (textContent?.includes(text)) {
          await option.click();
          await delay(500);
          return;
        }
      }

      console.warn(`Option with text "${text}" not found in select ${selectSelector}`);
    } catch (error) {
      console.error(`Error in selectByTextSimple: ${error}`);
    }
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/config.ts</path>
            <content><![CDATA[// src/config.ts
import * as fs from 'fs';
import * as path from 'path';
import * as TOML from 'toml';
import { DemoConfig } from './recorder/types';

export function getConfigPath(targetDir: string): string {
  return path.join(targetDir, '.demo-recorder.toml');
}

export function getExampleConfigPath(): string {
  return path.join(__dirname, '..', 'example-config.toml');
}

export function createConfigFile(configPath: string): void {
  const exampleConfigPath = getExampleConfigPath();
  
  if (!fs.existsSync(exampleConfigPath)) {
    throw new Error('Example config file not found. Please ensure example-config.toml exists in the project root.');
  }

  fs.copyFileSync(exampleConfigPath, configPath);
  console.log(`Created new config file at ${configPath}`);
  console.log('Please customize the config file for your specific needs.');
}

function interpolateEnvVariables(obj: any): any {
  if (typeof obj === 'string') {
    return obj.replace(/\${([^}]+)}/g, (match, envVar) => {
      // Check if it's a nested reference like auth.email
      const parts = envVar.split('.');
      if (parts.length > 1) {
        return match; // Keep the original ${auth.email} format for nested refs
      }
      return process.env[envVar] || match;
    });
  }

  if (Array.isArray(obj)) {
    return obj.map(item => interpolateEnvVariables(item));
  }

  if (obj && typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = interpolateEnvVariables(value);
    }
    return result;
  }

  return obj;
}

function interpolateConfigReferences(config: any): any {
  let stringified = JSON.stringify(config);
  
  // Replace ${auth.email} and similar with actual values
  stringified = stringified.replace(/\${([^}]+)}/g, (match, path) => {
    const parts = path.split('.');
    let value = config;
    for (const part of parts) {
      if (value && typeof value === 'object' && part in value) {
        value = value[part];
      } else {
        return match; // Keep original if path not found
      }
    }
    return typeof value === 'string' ? value : match;
  });

  return JSON.parse(stringified);
}

export function readConfig(configPath: string): DemoConfig {
  try {
    const content = fs.readFileSync(configPath, 'utf-8');
    let config = TOML.parse(content) as DemoConfig;
    
    // First interpolate environment variables
    config = interpolateEnvVariables(config);
    
    // Then interpolate config references
    config = interpolateConfigReferences(config);
    
    return config;
  } catch (error) {
    console.error(`Error reading config at ${configPath}:`, error);
    throw error;
  }
}

export function ensureConfigExists(targetDir: string): string {
  const configPath = getConfigPath(targetDir);
  if (!fs.existsSync(configPath)) {
    createConfigFile(configPath);
  }
  return configPath;
}

export function initializeConfig(targetDir: string): DemoConfig {
  const configPath = ensureConfigExists(targetDir);
  return readConfig(configPath);
}
]]></content>
          </file>
        
          <file>
            <path>src/index.ts</path>
            <content><![CDATA[// src/index.ts
import * as path from 'path';
import * as fs from 'fs';
import { initializeConfig, ensureConfigExists } from './config';
import { DemoRecorder } from './recorder/CustomScreenRecorder';

// Get command line arguments
const args = process.argv.slice(2);
let command = 'record';  // default command
let targetDir = process.cwd();  // default directory

// If we have arguments, check their order
if (args.length > 0) {
  // If the first arg is a command, use it and look for dir in second arg
  if (args[0] === 'init' || args[0] === 'record') {
    command = args[0];
    targetDir = args[1] ? path.resolve(args[1]) : process.cwd();
  } else {
    // If first arg isn't a command, it must be the directory
    targetDir = path.resolve(args[0]);
  }
}

console.log(`Command: ${command}`);
console.log(`Target directory: ${targetDir}`);

async function init() {
  try {
    if (!fs.existsSync(targetDir)) {
      console.error(`Error: Target directory does not exist: ${targetDir}`);
      process.exit(1);
    }

    console.log(`Initializing demo recorder config in: ${targetDir}`);
    
    // This will create the config file if it doesn't exist
    const configPath = ensureConfigExists(targetDir);
    
    console.log('\nConfiguration file created successfully!');
    console.log(`Please edit ${configPath} to configure your recording steps.`);
    console.log('\nOnce configured, you can run:');
    console.log('demo-record');
    console.log('\nto start the recording.');

  } catch (error) {
    console.error('Initialization failed:', error);
    process.exit(1);
  }
}

async function record() {
  try {
    if (!fs.existsSync(targetDir)) {
      console.error(`Error: Target directory does not exist: ${targetDir}`);
      process.exit(1);
    }

    console.log(`Starting demo recorder for directory: ${targetDir}`);

    // Load and validate config
    const config = initializeConfig(targetDir);

    // Create output directory if specified in config
    const outputDir = path.dirname(path.join(targetDir, config.recording.output));
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Initialize and run recorder
    const recorder = new DemoRecorder(config);
    await recorder.record();

  } catch (error) {
    console.error('Recording failed:', error);
    process.exit(1);
  }
}

// Main execution
async function main() {
  try {
    switch (command) {
      case 'init':
        await init();
        break;
      case 'record':
        await record();
        break;
      default:
        console.error('Unknown command. Use "init" or "record"');
        process.exit(1);
    }
  } catch (error) {
    console.error('Unexpected error:', error);
    process.exit(1);
  }
}

// Run the main function
main().catch((error) => {
  console.error('Unexpected error:', error);
  process.exit(1);
});
]]></content>
          </file>
        
          <file>
            <path>src/recorder/CustomScreenRecorder.ts</path>
            <content><![CDATA[//src/recorder/CustomScreenRecorder.ts
import * as puppeteer from 'puppeteer';
import { spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import { MouseActions } from '../actions/MouseActions';
import { InputActions } from '../actions/InputActions';
import { SelectActions } from '../actions/SelectActions';
import { delay } from '../utils/delay';
import { DemoConfig, RecordingOptions } from './types';
import { checkMouseHelper } from '../utils/mouse-helper';

class CustomScreenRecorder {
  private ffmpeg: any;
  private frameCount: number = 0;
  private client: puppeteer.CDPSession | null = null;
  private isRecording: boolean = false;
  private isPaused: boolean = false;
  private pausedTime: number = 0;

  public getStatus() {
    return {
      isRecording: this.isRecording,
      isPaused: this.isPaused
    };
  }


  constructor(
    private page: puppeteer.Page,
    private options: RecordingOptions = {
      fps: 30,
      quality: 90,
      videoCrf: 18,
      videoCodec: 'libx264',
      videoPreset: 'ultrafast'
    }
  ) { }

  async start(outputPath: string): Promise<void> {
    // Ensure the output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    this.client = await this.page.createCDPSession();
    this.isRecording = true;
    this.isPaused = false;

    this.ffmpeg = spawn('ffmpeg', [
      '-y',
      '-f', 'image2pipe',
      '-r', `${this.options.fps}`,
      '-i', '-',
      '-c:v', this.options.videoCodec,
      '-preset', this.options.videoPreset,
      '-crf', `${this.options.videoCrf}`,
      '-pix_fmt', 'yuv420p',
      outputPath
    ]);

    this.ffmpeg.stderr.on('data', (data: Buffer) => {
      console.log(`FFmpeg: ${data.toString()}`);
    });

    await this.client.send('Page.startScreencast', {
      format: 'jpeg',
      quality: this.options.quality,
      everyNthFrame: 1
    });

    await this.client.on('Page.screencastFrame', async (frame) => {
      try {
        if (!this.client) return;

        this.ffmpeg.stdin.write(Buffer.from(frame.data, 'base64'));
        this.frameCount++;

        await this.client.send('Page.screencastFrameAck', {
          sessionId: frame.sessionId
        }).catch(console.error);
      } catch (error) {
        console.error('Error processing frame:', error);
      }
    });
  }

  async stop(): Promise<void> {
    if (this.client) {
      try {
        await this.client.send('Page.stopScreencast');
        this.ffmpeg.stdin.end();

        await new Promise<void>((resolve, reject) => {
          this.ffmpeg.on('close', (code: number) => {
            if (code === 0) {
              console.log(`Recording completed with ${this.frameCount} frames`);
              resolve();
            } else {
              reject(new Error(`FFmpeg exited with code ${code}`));
            }
          });
        });

        await this.client.detach();
        this.client = null;
      } catch (error) {
        console.error('Error stopping recording:', error);
        throw error;
      }
    }
  }

  async pause(): Promise<void> {
    if (!this.isRecording || this.isPaused) return;

    if (this.client) {
      await this.client.send('Page.stopScreencast');
      this.isPaused = true;
      this.pausedTime = Date.now();
      console.log('Recording paused');
    }
  }

  async resume(): Promise<void> {
    if (!this.isRecording || !this.isPaused) return;

    if (this.client) {
      await this.client.send('Page.startScreencast', {
        format: 'jpeg',
        quality: this.options.quality,
        everyNthFrame: 1
      });
      this.isPaused = false;
      console.log(`Recording resumed after ${Date.now() - this.pausedTime}ms pause`);
    }
  }
}

class DemoRecorder {
  private browser?: puppeteer.Browser;
  private page?: puppeteer.Page;
  private recorder?: CustomScreenRecorder;
  private mouseActions?: MouseActions;
  private inputActions?: InputActions;
  private selectActions?: SelectActions;

  constructor(private config: DemoConfig) { }

  async initialize() {
    this.browser = await puppeteer.launch({
      headless: false,
      defaultViewport: this.config.project.viewport
    });

    this.page = await this.browser.newPage();
    await this.initializeMouseHelper();

    await checkMouseHelper(this.page);

    this.recorder = new CustomScreenRecorder(this.page);
    this.mouseActions = new MouseActions(this.page);
    this.inputActions = new InputActions(this.page);
    this.selectActions = new SelectActions(this.page);
  }

  private async initializeMouseHelper() {
    if (!this.page) throw new Error('Page not initialized');

    try {
      const mouseHelperPath = require.resolve('mouse-helper/dist/mouse-helper.js');
      console.log('Mouse helper path:', mouseHelperPath);
      const mouseHelperContent = fs.readFileSync(mouseHelperPath, 'utf8');
      console.log('Mouse helper content loaded, length:', mouseHelperContent.length);

      // Add the mouse-helper script to be evaluated on each new document
      await this.page.evaluateOnNewDocument(mouseHelperContent);

      // Also initialize it on the current page
      await this.page.evaluate(mouseHelperContent);

      // Add initialization calls
      await this.page.evaluateOnNewDocument(`
        window.self = window;
        window.addEventListener('load', () => {
          if (typeof window['mouse-helper'] === 'function') {
            console.log('Initializing mouse helper on load');
            window['mouse-helper']();
          } else {
            console.error('Mouse helper function not found on load');
          }
        });
        if (document.readyState === 'complete') {
          if (typeof window['mouse-helper'] === 'function') {
            console.log('Initializing mouse helper immediately');
            window['mouse-helper']();
          }
        }
      `);

      // Initialize on current page if already loaded
      await this.page.evaluate(`
        window.self = window;
        if (typeof window['mouse-helper'] === 'function') {
          console.log('Initializing mouse helper on current page');
          window['mouse-helper']();
        } else {
          console.error('Mouse helper function not found on current page');
        }
      `);

    } catch (error) {
      console.error('Failed to initialize mouse helper:', error);
      console.error('Error details:', error instanceof Error ? error.message : String(error));
    }
  }

  async executeStep(step: any) {
    if (!this.page || !this.mouseActions || !this.inputActions || !this.selectActions) {
      throw new Error('Recorder not properly initialized');
    }

    try {
      console.log(`Executing step: ${step.type}`);

      switch (step.type) {
        case 'navigate':
          console.log(`Navigating to: ${this.config.project.baseUrl}${step.path}`);
          await this.page.goto(`${this.config.project.baseUrl}${step.path}`, {
            waitUntil: ['networkidle0', 'load']
          });
          await delay(1000); // Give time for mouse helper to initialize
          break;

          case 'input':
            console.log(`Typing into: ${step.selector}`);
            const typeConfig = {
              ...this.config.recording.defaultTypeConfig,
              ...step.typeConfig
            };
            await this.inputActions.typeText(step.selector!, step.value!, {
              isTextarea: step.selector?.includes('textarea'),
              delay: typeConfig.slowType ? (typeConfig.typeDelay || 150) : 50
            });
          break;

        case 'select':
          console.log(`Selecting from: ${step.selector}`);
          await this.selectActions.select(step.selector!, step.option!);
          break;

        case 'click':
          console.log(`Clicking: ${step.selector}`);
          await this.mouseActions.click(step.selector!);
          break;

        case 'wait':
          console.log(`Waiting: ${step.duration}ms`);
          await delay(step.duration || 1000);
          break;

        case 'startRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.start(this.config.recording.output);
          break;

        case 'stopRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.stop();
          break;

        case 'pauseRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.pause();
          break;

        case 'resumeRecording':
          if (!this.recorder) throw new Error('Recorder not initialized');
          await this.recorder.resume();
          break;

        default:
          console.warn(`Unknown step type: ${step.type}`);
      }
    } catch (error) {
      console.error(`Error executing step ${step.type}:`, error);
      throw error;
    }
  }

  async record() {
    try {
      await this.initialize();
      if (!this.page || !this.recorder) throw new Error('Failed to initialize');
  
      // Don't auto-start recording - wait for a startRecording step
      for (const step of this.config.steps) {
        await this.executeStep(step);
      }
  
      // Only stop if we're still recording at the end
      if (this.recorder.getStatus().isRecording) {
        console.log('Stopping recording...');
        await this.recorder.stop();
      }
    } catch (error) {
      console.error('Recording error:', error);
      throw error;
    } finally {
      if (this.browser) {
        await this.browser.close();
      }
    }
  }
}

export { CustomScreenRecorder, DemoRecorder };
]]></content>
          </file>
        
          <file>
            <path>src/recorder/types.ts</path>
            <content><![CDATA[// src/recorder/types.ts

export interface ViewportDimensions {
  width: number;
  height: number;
}

export interface RecordingOptions {
  fps: number;
  quality: number;
  videoCrf: number;
  videoCodec: string;
  videoPreset: string;
}

export interface TypeConfig {
  slowType?: boolean;
  typeDelay?: number;  // milliseconds between keystrokes
}

export interface Step {
  type: StepType;
  selector?: string;
  value?: string;
  option?: string;
  duration?: number;
  path?: string;
  typeConfig?: TypeConfig;
}

export type StepType = 
  | 'navigate' 
  | 'input' 
  | 'select' 
  | 'click' 
  | 'wait'
  | 'startRecording'
  | 'stopRecording'
  | 'pauseRecording'
  | 'resumeRecording';


export interface ProjectConfig {
  name: string;
  baseUrl: string;
  viewport: ViewportDimensions;
}

export interface AuthConfig {
  email?: string;
  password?: string;
}

export interface RecordingConfig {
  output: string;
  fps: number;
  quality: number;
  defaultTypeConfig?: TypeConfig;
}

export interface DemoConfig {
  project: ProjectConfig;
  auth?: AuthConfig;
  recording: RecordingConfig;
  steps: Step[];
}
]]></content>
          </file>
        
          <file>
            <path>src/utils/browser.ts</path>
            <content><![CDATA[// src/utils/browser.ts
import * as puppeteer from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';

interface BrowserOptions {
  headless?: boolean;
  viewport?: {
    width: number;
    height: number;
  };
  userDataDir?: string;
}

/**
 * Initializes a Puppeteer browser with the specified options
 */
export async function initializeBrowser(options: BrowserOptions = {}) {
  const defaultOptions: BrowserOptions = {
    headless: false,
    viewport: {
      width: 1280,
      height: 800
    }
  };

  const mergedOptions = { ...defaultOptions, ...options };

  try {
    const browser = await puppeteer.launch({
      headless: mergedOptions.headless,
      defaultViewport: mergedOptions.viewport,
      userDataDir: mergedOptions.userDataDir,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu'
      ]
    });

    return browser;
  } catch (error) {
    console.error('Failed to initialize browser:', error);
    throw error;
  }
}

/**
 * Injects mouse helper script into the page for visualizing cursor movements
 */
export async function injectMouseHelper(page: puppeteer.Page) {
  try {
    // Get the path to the mouse-helper script
    const mouseHelperPath = require.resolve('mouse-helper/dist/mouse-helper.js');
    const mouseHelperContent = fs.readFileSync(mouseHelperPath, 'utf8');

    // Inject the mouse-helper script
    await page.evaluateOnNewDocument(`
      window.self = window;
      ${mouseHelperContent}
      if (document.readyState === 'complete') {
        window['mouse-helper']();
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          window['mouse-helper']();
        });
      }
    `);

    // Also inject it immediately in case we're after DOM ready
    await page.evaluate(`
      window.self = window;
      if (typeof window['mouse-helper'] === 'function') {
        window['mouse-helper']();
      }
    `);
  } catch (error) {
    console.error('Failed to inject mouse helper:', error);
    throw error;
  }
}

/**
 * Ensures the output directory exists for video recordings
 */
export async function ensureOutputDirectory(outputPath: string) {
  try {
    const dir = path.dirname(outputPath);
    await fs.promises.mkdir(dir, { recursive: true });
    return dir;
  } catch (error) {
    console.error('Failed to create output directory:', error);
    throw error;
  }
}

/**
 * Waits for network to be idle and page to be fully loaded
 */
export async function waitForPageLoad(page: puppeteer.Page, timeout = 30000) {
  try {
    await Promise.all([
      page.waitForNavigation({ 
        waitUntil: ['networkidle0', 'load', 'domcontentloaded'],
        timeout 
      }),
      page.waitForFunction(
        'document.readyState === "complete"',
        { timeout }
      )
    ]);
  } catch (error) {
    console.warn('Page load timeout or error:', error);
    // Don't throw - sometimes pages are usable before everything is fully loaded
  }
}

/**
 * Checks if an element is visible and clickable
 */
export async function isElementClickable(page: puppeteer.Page, selector: string): Promise<boolean> {
  try {
    const element = await page.$(selector);
    if (!element) return false;

    const isVisible = await page.evaluate((el) => {
      const style = window.getComputedStyle(el);
      return style && 
             style.display !== 'none' && 
             style.visibility !== 'hidden' && 
             style.opacity !== '0';
    }, element);

    if (!isVisible) return false;

    const box = await element.boundingBox();
    return box !== null;
  } catch {
    return false;
  }
}

/**
 * Safely closes a browser instance
 */
export async function closeBrowser(browser: puppeteer.Browser | undefined) {
  try {
    if (browser) {
      const pages = await browser.pages();
      await Promise.all(pages.map(page => page.close()));
      await browser.close();
    }
  } catch (error) {
    console.error('Error closing browser:', error);
    // Don't throw - this is cleanup code
  }
}
]]></content>
          </file>
        
          <file>
            <path>src/utils/delay.ts</path>
            <content><![CDATA[// src/utils/delay.ts
/**
 * Creates a promise that resolves after a specified number of milliseconds
 * @param ms Number of milliseconds to wait
 * @returns Promise that resolves after the specified delay
 */
export const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));]]></content>
          </file>
        
          <file>
            <path>tsconfig.json</path>
            <content><![CDATA[{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020", "DOM"],
    "outDir": "dist",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.test.ts"]
}
]]></content>
          </file>
        
  </fileContents>
</projectContext>